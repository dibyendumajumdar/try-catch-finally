#summary Collection of various bits about Go Internals

= Introduction =

The material here is gathered from various sources and in some cases is derived from information obtained by reading Go source code.

= GoRoutines =

== History ==
GoRoutines in Go are based upon previous work done by the Go inventors at Bell Labs. A good account of this history can be here:

[http://swtch.com/~rsc/thread/ http://swtch.com/~rsc/thread/]

Goroutines are multiplexed across threads. The goroutine's stack is managed by the Go compiler/runtime independently of the OS stack, which is why calling external C functions require the stacks to be switched. 

Goroutines are cooperatively scheduled by the Go scheduler (implemented in runtime/proc.c). The Gosched(0 is called at suitable times, such as when a goroutine is about to block in a system call or when getting a lock.

The Go runtime maintains a pool of threads for running goroutines. If a particular goroutine will block due to a system call, a new thread is created if there are other goroutines waiting to run. The runtime requires that either goroutines be blocked in a system call, or at least one goroutine must be runnable. If this is not true, then the runtime aborts with an error reporting a deadlock. 

= Difference between goc and cgo =

Paraphrased from [http://groups.google.com/group/golang-nuts/browse_thread/thread/d1824928719244c6/100b92392a42b7af?lnk=gst&q=goc+cgo#100b92392a42b7af discussion on implementing SWIG interface]

There are two different mechanisms for interfacing with C. One is for writing Go code to wrap C, and the other is for writing C code to implement Go. 

cgo is the preferred method for integrating with external C libraries.  cgo is the one with the import "C" lines and which is documented by  'godoc cgo' and http://golang.org/cmd/cgo/. This is the one people are encouraged to use. 

The examples of using this tool are in `$GOROOT/misc/cgo/*`; these help to make clear how to write cgo code. The pseudo-package "C" contains whatever C symbols you would like to use, as possible.  It also contains two pre-defined symbols that you won't find in the C libraries: CString(s) allocates and returns a new C string that is a copy of the given Go string, and GoString(s) does the reverse. 

The cgo is for writing Go code that wraps external C code which has been compiled with gcc and is linked in at runtime as a shared library: think wrapping gmp, gtk, sdl, openssl, etc. Cgo's role is to let you write Go code that uses C by referring to names in the pseudo-package you get by doing import "C". 

Some files in src/pkg/runtime that were unfortunately named `*.cgo` (now renamed to `*.goc`).  Those use a different tool that can be thought of as a precursor to the "real" cgo. Those are for writing the low-level bits of runtime and are basically C files with some functions written using Go declarations instead of C declarations.  They cannot #include standard system libraries, only the low-level runtime headers, and they cannot include Go code - you're forced to write in C. That tool is intentionally undocumented. 

The unfortunately-named cgo2c in the runtime directory is for writing C code callable from Go to implement basic runtime operations like allocating data or concatenating strings. That C code is compiled with 6c, not gcc, and it is linked statically into the program just like a Go source file would be. Cgo2c's role is to let the Go compiler emit calls to runtime functions that happen to be implemented in C.  The only useful thing it does is rewrite the Go-style function declarations into equivalent C-style ones, inserting appropriate padding so that they end up with the same memory layout. 

= Overhead in calling C functions =

[http://groups.google.com/group/golang-nuts/browse_thread/thread/34d6a5b928242d25/2c786e7691b5bad1?q=#2c786e7691b5bad1 Discussion on overheads in calling C functions]

Relevant bits are paraphrased below:

The performance of a single cgo call is slower than a function call by a factor of 40. 

It is assumed by some people that cgo runs C calls in a separate thread, and thus calling a cgo call involves a thread switch.  That is not true. Cgo does run C calls on a separate stack, the one that was allocated by the operating system and is thus assumed to be big enough to run ordinary C code (the goroutine stacks are not). It's cheap - just a couple register moves.  If this is not done, the C function will overflow the goroutine stack and suffer silent, mysterious memory corruption.  

The expense comes from coordinating with the scheduler, which requires lock(&sched) and unlock(&sched) both before and after the call, each of which does a ~50ns atomic memory operation.  A very clever implementation 
might be able to get it down to one memory operation, so 100 ns instead of 200 ns. If the program ever blocks inside the called C code, the other goroutines will not get a chance to run unless GOMAXPROCS is set to > # of blocked threads. 

Even if GOMAXPROCS is set big enough to avoid the deadlock, if there is no coordination with the scheduler, the garbage collector is going to sit and wait for the C calls to finish, which will cause its own deadlock or at least slowdown, unless they're fairly responsive. It's not something that can be easily brushed aside or ignored in the general case. 

If the overhead is being noticed, it means that very little is happening inside the called C functions. Anything that does a modicum of work should not notice the overhead, but C calls should not be put in a tight loop like: 
{{{
   for i := 0; i < C.vectorlen(v); i++ { 
      s += C.vectorat(v, i) 
   } 
}}}
Something like that is definitely going to hurt. 

If only C functions that return quickly (they never block indefinitely) are called, the first diff below can be applied to cut out the scheduler coordination. (On Russ's system that cuts the C no-op time to about 40 ns). For more aggressive optimisation and if callbacks are never used, the second diff below can be applied, which cuts out even more things that are needed in genera case.  (On Russ's system that cuts the C no-op time down to 20 ns). 

{{{
$ hg diff cgocall.c 
diff -r 483f23f89563 src/pkg/runtime/cgocall.c 
--- a/src/pkg/runtime/cgocall.c Tue Jun 08 22:32:04 2010 -0700 
+++ b/src/pkg/runtime/cgocall.c Wed Jun 09 01:45:23 2010 -0700 
@@ -34,9 +34,7 @@ 
         * M to run goroutines while we are in the 
         * foreign code. 
         */ 
-       路entersyscall(); 
        runcgo(fn, arg); 
-       路exitsyscall(); 
        m->lockedg = oldlock; 
        if(oldlock == nil) 
$ 
$ hg diff . 
diff -r 483f23f89563 src/pkg/runtime/amd64/asm.s 
--- a/src/pkg/runtime/amd64/asm.s       Tue Jun 08 22:32:04 2010 -0700 
+++ b/src/pkg/runtime/amd64/asm.s       Wed Jun 09 01:44:33 2010 -0700 
@@ -299,14 +299,6 @@ 
        MOVQ    m, 16(SP) 
        MOVQ    CX, 8(SP) 
-       // Save g and m values for a potential callback.  The callback 
-       // will start running with on the g0 stack and as such should 
-       // have g set to m->g0. 
-       MOVQ    m, DI           // DI = first argument in AMD64 ABI 
-                               // SI, second argument, set above 
-       MOVQ    libcgo_set_scheduler(SB), BX 
-       CALL    BX 
- 
        MOVQ    R13, DI         // DI = first argument in AMD64 ABI 
        CALL    R12 
diff -r 483f23f89563 src/pkg/runtime/cgocall.c 
--- a/src/pkg/runtime/cgocall.c Tue Jun 08 22:32:04 2010 -0700 
+++ b/src/pkg/runtime/cgocall.c Wed Jun 09 01:44:33 2010 -0700 
@@ -13,36 +13,7 @@ 
 void 
 cgocall(void (*fn)(void*), void *arg) 
 { 
-       G *oldlock; 
- 
-       if(initcgo == nil) 
-               throw("cgocall unavailable"); 
- 
-       ncgocall++; 
- 
-       /* 
-        * Lock g to m to ensure we stay on the same stack if we do a 
-        * cgo callback. 
-        */ 
-       oldlock = m->lockedg; 
-       m->lockedg = g; 
-       g->lockedm = m; 
- 
-       /* 
-        * Announce we are entering a system call 
-        * so that the scheduler knows to create another 
-        * M to run goroutines while we are in the 
-        * foreign code. 
-        */ 
-       路entersyscall(); 
        runcgo(fn, arg); 
-       路exitsyscall(); 
- 
-       m->lockedg = oldlock; 
-       if(oldlock == nil) 
-               g->lockedm = nil; 
- 
-       return; 
 } 

}}}


#summary Specification of a new Language for the JVM

= Introduction =

This is the specification for a new programming language for the JVM. 

The new language is an attempt to implement a Google Go type language on the JVM. The goal is to keep to the features supported efficiently in the JVM but (taking inspiration from Go), reduce the verbosity in the language, and add some concurrency features to the language.

The key features proposed in the new language are:

  * static type inference (I am aware of the arguments for/against but on balance prefer to support this, while allowing explicit type declarations where needed).
  * channels - add syntactic support for creating either a synchronous or buffered queue (using standard Java concurrency library)
  * maps - syntactic support for hash maps
  * tasks - syntactic support for submitting tasks to a thread pool using the concurrency library
  * convention over boilerplate  - like Go, if an identifier starts with a capital, make it automatically public, else private, and use similar techniques to reduce boilerplate stuff
  * static methods should not have to be declared in a class - to automatically create a default class per package to hold static methods
  * will use standard Java libraries; no language specific library
  * completely interoperable with Java; it will be possible to invoke existing Java code from the new language without any extra effort, and conversely, it should be possible to invoke code implemented in the new language from Java.
  * must be a small language with few constructs/keywords - smaller than Java if possible (but some additions for syntactic support for maps, channels, tasks, etc.). It should be possible for a Java programmer to learn in a day.
  * not a scripting or dynamic language - main use case is writing server applications. 
  * should provide an API for replacing default implementations of certain built in types such as channels, maps, threadpools, tasks etc. so that the implementations are pluggable.
  * similar to Go but not exactly the same - no point adding a feature that cannot be done efficiently in the JVM. 
  * will support closures, but implementation may be deferred until JVM 7 becomes available
  * will allow use of generics implemented in Java, but no support for creating generic types (this may change later). 

Non Features 
  * Go interfaces; the new language will support standard Java type interfaces
  * No support for the select command in Go
  * defer/panic/recover - standard try/catch/finally as in Java
  * Any thing else that does not map directly to a feature in Java. 

== Status ==
Just ideas right now. Work will soon start on creating a pre-processor that translates to Java.

== Grammer ==
Todo

== Specification ==
Todo

== Examples/equivalent Java code ==

Note that these are tentative, and likely to change/evolve.

=== hello world ===
{{{
module my.pkg
func Main() {
  print("Hello World!")
}
}}}

translates to:

{{{
package my.pkg;
public final class Statics {
  public static void main(String[] args) {
    System.out.println("Hello World");
  }
}
}}}

=== Another example ===
{{{
module my.pkg
func Main() {
  for i := 0; i < 10; i++ {
    print("i = " + i)
  }
}
}}}

is converted to:

{{{
package my.pkg;
public final class Statics {
  public static void main(String[] args) {
    for (int i = 0; i < 10; i++) {
      System.out.println("i = " + i);
    }
  }
}
}}}

=== More functions ===

{{{
module my.pkg
func add(a, b int) int {
  return a+b
}
}}}

Translates to:

{{{
package my.pkg;
public final class Statics {
  static int add(int a, int b)  {
    return a+b;
  }
}
}}}

=== Classes and Interfaces ===

{{{
module my.pkg
interface Lock {
  Lock()
  Unlock()
  IsLocked() bool
}

// MyLock implements interface Lock
type MyLock : Lock {
  locked bool
}

func MyLock.Lock() {
  locked = true
}

func MyLock.Unlock() {
  locked = false
}

func MyLock.IsLocked() bool {
  return locked
}
}}}

Maybe also support:

{{{
type MyLock : Lock {
  locked bool
  func Lock() {
    locked = true
  }
  func Unlock() {
    locked = false
  }
  func IsLocked() bool {
    return locked
  }
}
}}}

By default classes and methods are final.
Therefore above translates to:

{{{
package my.pkg;
public interface Lock {
  void Lock();
  void Unlock();
  boolean IsLocked();
}

// All classes are translated as final unless explicitly marked
inheritable
public final class MyLock implements Lock {
  boolean locked;
  public final void Lock() {
    locked = true;
  }
  public final void Unlock() {
    locked = false;
  }
  public final boolean IsLocked() {
    return locked;
  }
}
}}}

=== Variables ===
{{{
module my.pkg
func foo() {
  s := "hello"
  i := 0
  g := 5.5
}

func bar() {
  var a, b int
  var s, t string
  var f float
}

func maps() {
  m := new map[string] int { "a": 1, "b": 2, "c": 3}
  m["z"] ?= 26
  array := new [] int { 1, 2, 3, 4}
  for i:array {
    print(i)
  }
}
}}}

translates to:

{{{
package my.pkg;

import java.util.concurrent.ConcurrentHashMap;

public final class Statics {

  static void foo() {
    String s = "hello";
    int i = 0;
    double g = 5.5;
  }

  static void bar() {
    int a, b;
    String s, t;
    double f;
  }

  static void maps() {
    ConcurrentHashMap<String, Integer> m = new ConcurrentHashMap<String, Integer>();
    m.put("a", 1);
    m.put("b", 2);
    m.put("c", 3);
    m.putIfAbsent("z", 26);
    int[] array = new int[] { 1, 2, 3, 4 };
    for (int i : array) {
      System.out.println(i);
    }
  }
}
}}}

=== Channels ===
{{{
module my.pkg
func producer(c1 chan int, N int, s chan bool) {
  for i := 0; i < N; i++ {
    c1 <- i
  }
  s <- true
}

func consumer(c1 chan int, N int, s chan bool) {
  for i := 0; i < N; i++ {
    <-c1
  }
  s <- true
}

func Main() {
  const N = 5
  c1 := new chan int
  s := new chan bool
  run producer(c1, N, s)
  run consumer(c1, N, s)
  <-s
  <-s
}
}}}

Java version:

{{{
package my.pkg;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.SynchronousQueue;

public final class Statics {

  static void producer(SynchronousQueue<Integer> c1, int N, SynchronousQueue<Boolean> s) {
    try {
      for (int i = 0; i < N; i++) {
        c1.put(i);
      }
      s.put(true);
    } catch (InterruptedException e) {
      // map to RuntimeException?
    }
  }

  static void consumer(SynchronousQueue<Integer> c1, int N, SynchronousQueue<Boolean> s) {
    try {
      for (int i = 0; i < N; i++) {
        c1.take();
      }
      s.put(true);
    } catch (InterruptedException e) {
      // map to RuntimeException?
    }
  }

  // Should be anonymous
  final class ProducerRunnable implements Runnable {
    final SynchronousQueue<Integer> c1;
    final int N;
    final SynchronousQueue<Boolean> s;

    ProducerRunnable(SynchronousQueue<Integer> c1, int N, SynchronousQueue<Boolean> s) {
      this.c1 = c1;
      this.N = N;
      this.s = s;
    }

    public void run() {
      producer(c1, N, s);
    }
  }

  final class ConsumerRunnable implements Runnable {
    final SynchronousQueue<Integer> c1;
    final int N;
    final SynchronousQueue<Boolean> s;

    ConsumerRunnable(SynchronousQueue<Integer> c1, int N, SynchronousQueue<Boolean> s) {
      this.c1 = c1;
      this.N = N;
      this.s = s;
    }
    public void run() {
      consumer(c1, N, s);
    }
  }

  // Just to show what happens conceptually
  static ExecutorService DefaultExecutorService = Executors.newCachedThreadPool();

  public static void main(String args[]) {
    try {
      SynchronousQueue<Integer> c1 = new SynchronousQueue<Integer>();
      SynchronousQueue<Boolean> s = new SynchronousQueue<Boolean>();
      final int N = 5;
      DefaultExecutorService.submit(new ProducerRunnable(c1, N, s));
      DefaultExecutorService.submit(new ConsumerRunnable(c1, N, s));
      s.take();
      s.take();
    } catch (Exception e) {
    } finally {
      DefaultExecutorService.shutdown();
    }
  }
}
}}}

=== More on channels ===

`chan string` maps to `SynchronousQueue<String>`

`chan(5) string` maps to `LinkedBlockingQueue<String>(5)`

`chan(?) string` maps to `ConcurrentLinkedQueue<String>` 

=== Atomic types and volatile ===

{{{
type T {
  stop volatile bool
  i atomic int
}
func T.ops() {
  i++
  ++i
  i = 3 ? 1;
  i--
  i += 1
  i -= 2
  v := i
  v = i++
}
func T.Stop() {
  stop = true
}
}}}

Translates to

{{{
public final class T {
  volatile boolean stop;
  AtomicInteger i = new AtomicInteger();

  final void ops() {
    i.getAndIncrement();
    i.incrementAndGet();
    i.compareAndSet(3, 1);
    i.getAndDecrement();
    i.addAndGet(1);
    i.addAndGet(-2);
    int v = i.get();
    v = i.getAndIncrement();
  }
  public final void Stop() {
    stop = true;
  }
}
}}}

=== importing Java types ===

{{{
// imported types can be given a local alias
// so in a way string is an alias for String
import java.util.ArrayList list

func foo() {
  v := new list<string>()
  v.add("hello")
  v.add("world")
  for x:v {
    print(x)
  }
}
}}}

translates to:

{{{
import java.util.ArrayList
public final class Statics {
  static void foo() {
    ArrayList<String> v = new ArrayList<String>();

    v.add("hello");
    v.add("world");
    for (String x:v) {
      System.out.println(x);
    }
  }
}
}}}

=== Generics ===

A generic interface:

{{{

interface List<T> {
  Next() T
  Add(T)
}
  
}}}

A generic class implementation:

{{{

type MyList<T> : List<T> {
}

func MyList<T>.Add(t T) {
}

func MyList<T>.Next() T {
  return null
}

}}}

=== Anonymous classes ===

The method declaration syntax is useful here:

{{{
  const name := "dibyendu"
  r := func Runnable.run() {
         print("hello" + name)
       }
  // submit the runnable instance to the threadpool
  run r
}}}

=== Discarding exceptions ===

{{{
// Support a syntax for discarding exceptions
func foo() {
  catch Thread.sleep(2)    // silently consumes InterruptedException
}
}}}

translates to:

{{{
public final class Statics {
  static void foo() {
    try {
      Thread.sleep(2)
    } catch (Exception e) {
      // ignored
    }
  }
}
}}}

=== Exceptions ===
{{{
import java.io.FileReader
// a default try/catch/finally block
// this might be too wierd !!!
func foo()  {
  f := new FileReader("testfile")
} catch e {
  e.printStackTrace()
} finally {
  catch f.close()
}
}}}

translates to

{{{
import java.io.FileReader
public final class Statics {
  static void foo() {
    FileReader f = null;
    try {
      f = new FileReader("testfile");
    } catch (Exception e) {
      e.printStackTrace();
    } finally {
    if (f != null) {
      try {
        f.close();
      } catch (Exception e) {
      }
    }
  }
}
}}} 